#' @title Reads profile data from raw output file from a CTM CTD
#'
#' @description Reads a data from an output file generated by a CTM CTD.
#'
#' @param filename Name of the file to read, including the file extension
#' @param keep names of the columns to retain in the output. Defaults to `"all"``
#' @param header the names of the columns in the raw data file. Defaults to `"auto"`
#' @param TZ time zone given to the output datetimes, defaults to `"UTC"`` (recommended)
#' @param clean Should the profile be cleaned? (logical)
#'
#' @details
#' This function first gleans information from the filename using `get_profile_info()`,
#' including the sampling location from the beginning of the filename,
#' and the sonde number from the file extension.
#' It parses the file and begins to read data 2 lines after the keyword "Datasets".
#' It assigns the names in `header` to the columns. If `header` is set to `"auto"`,
#' it will assign hard coded names according to the sonde number, hoping that one sonde always thas the same sensors attached.
#' It converts the date and time columns to a POSIX datetime with the timezone `TZ`.
#' The function finally drops any columns that are not named in `keep`.
#' If `keep` contains names not found in the header, it will add a column of `NA`s for each unfound name.
#' The `header` can include `c("no","press","temp","cond","cond_hi","salin","DO_sat","DO","pH","turb","chla","BGAPE","BGAPC","sv","intD","intT")`
#'
#' @return A `data.frame` containing the profile data
#'
#' @author Tom Shatwell
#'
#' @seealso \code{\link{get_profile_info}}, \code{\link{read_bbe}}, \code{\link{clean_profile}}, \code{\link{batch_read}}
#'
#' @examples
#' \dontrun{
#' pr_loc <- system.file("extdata", package="seefo")
#' pr_name <- file.path(pr_loc,  "profiles","20170801","YT1_20170801_1.CTM644")
#' pr1 <- read_ctm(pr_name)
#' head(pr1)
#' }
#'
#' @export

read_ctm <- function(filename, keep="all", header="auto", TZ="UTC", clean=TRUE) {
  info <- get_profile_info(filename) # extracts info from the filename
  ext <- info["ext"] # sonde name comes from the file extension
  if(!grepl(pattern = "CTM", x = ext)) {
    warning("File does not have a CTM extension, attempting anyway...")
  }
  top <- readLines(con = filename,n=50) # read the top 50 lines of the file
  skip <- grep(pattern = "Datasets", x = top) +2 # skip to 2 lines after the "Datasets" header

  # header1 <- c("no","press","temp","cond","salin",
  #              "DO_sat","DO")
  # header2 <- c("pH","turb","chla")
  # header3 <- c("intD","intT")
  # header <- c(header1, header2, header3)
  if(header[1]=="auto") {
    header <- c("no","press","temp","cond","salin",
                "DO_sat","DO","pH","turb","chla",
                "intD","intT")
    if(ext == "CTM294") {
      # header <- c(header1,"h2s", header2, header3)
      header <- c("no","press","temp","cond","salin",
                  "DO_sat","DO","h2s","pH","turb","chla",
                  "intD","intT")
    }

    if(ext == "CTM102") {
      # header <- c(header1,header3)
      header <- c("no","press","temp","cond","salin",
                  "DO_sat","DO",
                  "intD","intT")
    }
    if(ext == "CTM1143") {
      # header <- c(header1,header2, c("BGAPE","BGAPC","sv"), header3)
      header <- c("no","press","temp","cond","cond_hi","salin",
                  "DO_sat","DO","pH","turb","chla",
                  "BGAPE","BGAPC","sv",
                  "intD","intT")
    }
  }


  dat <- utils::read.table(file = filename, skip = skip, header = FALSE, #sep = "\t",
                    dec = ".")
  names(dat) <- header
  dt <- as.POSIXct(paste(strptime(dat$intD,
                                  format="%d.%m.%Y", tz=TZ),
                         dat$intT), tz=TZ)
  if(keep[1]=="all") {
    outvars <- header[!header %in% c("no","intD","intT")]
  } else outvars <- keep
  # keep <- c("press","temp","cond","salin",
  #           "DO_sat","DO","pH","turb","chla")

  if(sum(is.na(match(outvars,header)))>0) { # fill any missing columns with NA
    newcols <- outvars[!outvars %in% header]
    for(j in 1:length(newcols)) {
      dat <- cbind(dat,NA)
    }
    names(dat) <- c(header,newcols)
    # dat[,newcols] <- as.numeric(dat[,newcols])
  }

  dat <- data.frame(dt=dt,
    pr_dt = as.POSIXct(cut(dt[1],"min"),tz=TZ),
    sonde=ext,
    location=info["loc"],
    dat[,outvars], #,comment=info["comment"]
    row.names=NULL
  )

  if(clean) dat <- clean_profile(dat)

  return(dat)
}
