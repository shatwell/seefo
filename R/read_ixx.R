#' @title Reads profile data from raw output file from a CTD of type ixxx
#'
#' @description Reads a data from an output file generated by a ixx CTD.
#'
#' @param filename Name of the file to read, including the file extension
#' @param keep names of the columns to retain in the output. Defaults to `"all"`
#' @param clean Should the profile be cleaned? (logical)
#' @param TZ time zone given to the output datetimes, defaults to `"UTC"`(recommended)
#'
#' @details
#' This function first collects information from the filename using `get_profile_info()`,
#' including the sampling location from the beginning of the filename,
#' and the sonde number from the file extension.
#' It begins to read data in the file 2 lines after the keyword "Datasets".
#' It assigns the names in `header` to the columns. If `header` is set to `"auto"`,
#' it will assign hard coded names according to the sonde number, hoping that one sonde always thas the same sensors attached.
#' It converts the date and time columns to a POSIX datetime with the timezone `TZ`.
#' The function finally drops any columns that are not named in `keep`.
#' If `keep` contains names not found in the header, it will add a column of `NA`s for each unfound name.
#'
#' @return A `data.frame` containing the profile data
#'
#' @author Tom Shatwell
#'
#' @seealso \code{\link{get_profile_info}},  \code{\link{read_ctm}}, \code{\link{read_bbe}}, \code{\link{batch_read}}
#'
#' @examples
#' \dontrun{
#' ixx <- read_ixx(add_later, ...)
#' }
#'
#' @export

read_ixx <- function(filename, keep = "all", clean=TRUE,
                     TZ="UTC") {
  info <- get_profile_info(filename) # extracts info from the filename
  ext <- info["ext"] # sonde name comes from the file extension
  if(!grepl(pattern = "i[*0-9]", x = ext)) {
    warning("File does not have ixxx extension, attempting anyway...")
  }
  # top <- readLines(con = filename,n=2) # read the top 50 lines of the file
  # header <- unlist(strsplit(x = top[1], split = "\t")) # assume line 1 is header
  #
  # for(i in 1:length(header)) {
  #   header[i] <- sub(pattern = "&", replacement = "", x = header[i]) # remove silly hash headings
  #   header[i] <- sub(pattern = "%", replacement = "", x = header[i]) # remove silly parentheses
  #   header[i] <- sub(pattern = "\\.", replacement = "", x = header[i]) # remove silly dots
  #   header[i] <- sub(pattern = " ", replacement = "_", x = header[i]) # replace spaces between words with "_"
  #   header[i] <- sub(pattern = " ", replacement = "_", x = header[i]) # replace spaces between words with "_"
  # }
  header <- c("depth","temp","cond","sal","DO_sat","DO_ppm","pH","Eh","turb","chl","bottle","time","date")
  if(ext == "i172") {
    header <- c("depth","temp","cond","sal","DO_sat","DO_ppm","pH","Eh",
                "turb","chl","bottle","time","date")
  }
  if(ext == "i152") {
    header <- c("depth","temp","condext","CdFresh","sal","DO_sat","DO_ppm","pH","Eh",
                "Tr","SVS_vel","time","date")
  }

  dat <- utils::read.table(file = filename, header = FALSE, dec = ",",
                           skip = 1)
  names(dat) <- header
  dt <- as.POSIXct(paste(strptime(dat$date,
                                  format="%d/%m/%Y", tz=TZ),
                         dat$time),tz=TZ)
  pr_dt = as.POSIXct(cut(dt[1],"min"),tz=TZ)
  if(keep[1]=="all") {
    outvars <- header[!header %in% c("date","time")]
  } else outvars <- keep

  for(j in outvars) dat[dat[,j] == "invalid",j] <- NA
  for(j in outvars) dat[,j] <- as.numeric(dat[,j])

  if(sum(is.na(match(outvars,header)))>0) { # fill any missing columns with NA
    newcols <- outvars[!outvars %in% header]
    for(j in 1:length(newcols)) {
      dat <- cbind(dat,NA)
    }
    names(dat) <- c(header,newcols)
  }

  dat <- data.frame(dt=dt,
                    pr_dt = pr_dt,
                    sonde=ext,
                    location=info["loc"],
                    dat[,outvars], #, comment=info["comment"]
                    row.names=NULL
  )

  if(clean) dat <- clean_profile(dat)

  return(dat)
}
