#' @title Reads profile data from raw output file from a CTM CTD
#'
#' @description Reads a data from an output file generated by a CTM CTD.
#'
#' @param filename Name of the file to read, including the file extension
#' @param keep names of the columns to retain in the output. Defaults to `"all"`
#' @param clean Should the profile be cleaned? (logical)
#' @param TZ time zone given to the output datetimes, defaults to `"UTC"` (recommended)
#'
#' @details
#' This function first collects information from the filename using `get_profile_info()`,
#' including the sampling location from the beginning of the filename,
#' and the sonde number from the file extension.
#' It parses the column names from the file, and then reads the data.
#' It converts the date and time columns to a POSIX datetime with the timezone `TZ`.
#' The function finally drops any columns that are not named in `keep`.
#' The new column `pr_dt` is a unique timestamp for that profile, which is useful when compiling lots of profiles.
#' If `keep` contains names not found in the header, it will add a column of `NA`s for each unfound name.
#' If you choose to `clean` the profile, this removes any air values, values from the upward cast,
#' and the lowest 0.5 m of the profile to avoid sediment contact.
#'
#'
#' @return A `data.frame` containing the profile data
#'
#' @author Tom Shatwell
#'
#' @seealso \code{\link{get_profile_info}},  \code{\link{read_ctm}}, \code{\link{clean_profile}}, \code{\link{batch_read}}
#'
#' @examples
#' \dontrun{
#' bbe_loc <- system.file("extdata", package="seefo")
#' bbe_name <- file.path(bbe_loc,  "profiles","20170801","YT1_20170801_1..FP2101")
#' bbe <- read_bbe(bbe_name)
#' head(bbe)
#' }
#'
#' @export

read_bbe <- function(filename, keep = c("depth","sample_temperature","Green_Algae","Bluegreen",
                                        "Diatoms","Cryptophyta","Yellow_substances","total_conc"),
                     clean = TRUE, TZ="UTC") {
  info <- get_profile_info(filename) # extracts info from the filename
  ext <- info["ext"] # sonde name comes from the file extension
  if(!grepl(pattern = "FP", x = ext)) {
    warning("File does not have FPxxxx extension, attempting anyway...")
  }
  # parse column names and convert into R-friendly names
  top <- readLines(con = filename,n=5) # read the top 5 lines of the file
  header <- unlist(strsplit(x = top[1], split = "\t")) # assume line 1 is header

  for(i in 1:length(header)) {
    header[i] <- sub(pattern = "#[0-9]\\(", replacement = "", x = header[i]) # remove silly hash headings
    header[i] <- sub(pattern = "\\)", replacement = "", x = header[i]) # remove silly parentheses
    header[i] <- sub(pattern = "\\.", replacement = "", x = header[i]) # remove silly dots
    header[i] <- sub(pattern = " ", replacement = "_", x = header[i]) # replace spaces between words with "_"
    header[i] <- sub(pattern = " ", replacement = "_", x = header[i]) # replace spaces between words with "_"
  }

  dat <- utils::read.table(file = filename, header = FALSE, dec = ",",
                           skip = 2, col.names = header)
  dt <- as.POSIXct(paste(strptime(dat$date,
                                      format="%d.%m.%Y", tz=TZ),
                         dat$time),tz=TZ)
  pr_dt = as.POSIXct(cut(dt[1],"min"),tz=TZ)

  if(keep[1]=="all") {
    outvars <- header[!header %in% c("date","time")]
  } else outvars <- keep

  for(j in outvars) dat[dat[,j] == "invalid",j] <- NA
  for(j in outvars) dat[,j] <- as.numeric(dat[,j])

  if(sum(is.na(match(outvars,header)))>0) { # fill any missing columns with NA
    newcols <- outvars[!outvars %in% header]
    for(j in 1:length(newcols)) {
      dat <- cbind(dat,NA)
    }
    names(dat) <- c(header,newcols)
  }

  dat <- data.frame(dt=dt,
                    pr_dt = pr_dt,
                    sonde=ext,
                    location=info["loc"],
                    dat[,outvars], #, comment=info["comment"]
                    row.names=NULL
  )

  if(clean) dat <- clean_profile(dat)

  return(dat)
}
