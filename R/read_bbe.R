#' @title Reads profile data from raw output file from a CTM CTD
#'
#' @description Reads a data from an output file generated by a CTM CTD.
#'
#' @param filename Name of the file to read, including the file extension
#' @param keep names of the columns to retain in the output. Defaults to `"all"`
#' @param clean Should the profile be cleaned? (logical)
#' @param TZ time zone given to the output datetimes, defaults to `"UTC"` (recommended)
#'
#' @details
#' This function first collects information from the filename using `get_profile_info()`,
#' including the sampling location from the beginning of the filename,
#' and the sonde number from the file extension.
#' It begins to read data in the file 2 lines after the keyword "Datasets".
#' It assigns the names in `header` to the columns. If `header` is set to `"auto"`,
#' it will assign hard coded names according to the sonde number, hoping that one sonde always thas the same sensors attached.
#' It converts the date and time columns to a POSIX datetime with the timezone `TZ`.
#' The function finally drops any columns that are not named in `keep`.
#' If `keep` contains names not found in the header, it will add a column of `NA`s for each unfound name.
#' The `header` can include `c("no","press","temp","cond","cond_hi","salin","DO_sat","DO","pH","turb","chla","BGAPE","BGAPC","sv","intD","intT")`
#'
#' @return A `data.frame` containing the profile data
#'
#' @author Tom Shatwell
#'
#' @seealso \code{\link{get_profile_info}},  \code{\link{read_ctm}}
#'
#' @examples
#' \dontrun{
#' bbe <- read_bbe(Ts = df[,2], Tb = df[,ncol(df)], dates = df[,1])
#' }
#'
#' @export

read_bbe <- function(filename, keep = c("depth","sample_temperature","Green_Algae","Bluegreen",
                                        "Diatoms","Cryptophyta","Yellow_substances","total_conc"),
                     clean = TRUE, TZ="UTC") {
  info <- get_profile_info(filename) # extracts info from the filename
  ext <- info["ext"] # sonde name comes from the file extension
  if(!grepl(pattern = "FP", x = ext)) {
    warning("File does not have FPxxxx extension, attempting anyway...")
  }
  # parse column names and convert into R-friendly names
  top <- readLines(con = filename,n=5) # read the top 5 lines of the file
  header <- unlist(strsplit(x = top[1], split = "\t")) # assume line 1 is header

  for(i in 1:length(header)) {
    header[i] <- sub(pattern = "#[0-9]\\(", replacement = "", x = header[i]) # remove silly hash headings
    header[i] <- sub(pattern = "\\)", replacement = "", x = header[i]) # remove silly parentheses
    header[i] <- sub(pattern = "\\.", replacement = "", x = header[i]) # remove silly dots
    header[i] <- sub(pattern = " ", replacement = "_", x = header[i]) # replace spaces between words with "_"
    header[i] <- sub(pattern = " ", replacement = "_", x = header[i]) # replace spaces between words with "_"
  }

  dat <- utils::read.table(file = filename, header = FALSE, dec = ",",
                           skip = 2, col.names = header)
  dt <- as.POSIXct(paste(strptime(dat$date,
                                      format="%d.%m.%Y", tz=TZ),
                         dat$time),tz=TZ)
  pr_dt = as.POSIXct(cut(dt[1],"min"),tz=TZ)

  if(keep[1]=="all") {
    outvars <- header[!header %in% c("date","time")]
  } else outvars <- keep

  for(j in outvars) dat[dat[,j] == "invalid",j] <- NA
  for(j in outvars) dat[,j] <- as.numeric(dat[,j])

  if(sum(is.na(match(outvars,header)))>0) { # fill any missing columns with NA
    newcols <- outvars[!outvars %in% header]
    for(j in 1:length(newcols)) {
      dat <- cbind(dat,NA)
    }
    names(dat) <- c(header,newcols)
  }

  dat <- data.frame(dt=dt,
                    pr_dt = pr_dt,
                    sonde=ext,
                    location=info["loc"],
                    dat[,outvars], #, comment=info["comment"]
                    row.names=NULL
  )

  if(clean) dat <- clean_profile(dat)

  return(dat)

  # return(data.frame(dt=dt,
  #                   pr_dt = pr_dt,
  #                   sonde=ext,
  #                   location=info["loc"],
  #                   dat[,outvars], #, comment=info["comment"]
  #                   row.names=NULL
  # ))
}
