#' @title Reads profile data from raw output file from an RBR CTD
#'
#' @description Reads a data from an output file generated by an RBR CTD.
#'
#' @param filename Name of the file to read, including the file extension
#' @param keep names of the columns to retain in the output. Defaults to `"all"``
#' @param header the names of the columns in the raw data file. Defaults to `"auto"`
#' @param TZ time zone given to the output datetimes, defaults to `"UTC"`` (recommended)
#' @param clean Should the profile be cleaned? (logical)
#' @param ... Arguments to be passed to `clean_profile()`
#'
#' @details
#' This function first gleans information from the filename using `get_profile_info()`,
#' including the sampling location from the beginning of the filename,
#' and the sonde number from the file extension.
#' It parses the file and begins to read data 2 lines after the keyword "Datasets".
#' It assigns the names in `header` to the columns. If `header` is set to `"auto"`,
#' it will assign hard coded names according to the sonde number, hoping that one sonde always thas the same sensors attached.
#' It converts the date and time columns to a POSIX datetime with the timezone `TZ`.
#' The function finally drops any columns that are not named in `keep`.
#' If `keep` contains names not found in the header, it will add a column of `NA`s for each unfound name.
#' The `header` can include `c("no","press","temp","cond","cond_hi","salin","DO_sat","DO","pH","turb","chla","BGAPE","BGAPC","sv","intD","intT")`
#'
#' @return A `data.frame` containing the profile data
#'
#' @author Patrick Aurich, Tom Shatwell
#'
#' @seealso \code{\link{get_profile_info}}, \code{\link{read_bbe}}, \code{\link{clean_profile}}, \code{\link{batch_read}}
#'
#' @examples
#' \dontrun{
#' pr_loc <- system.file("extdata", package="seefo")
#' pr_name <- file.path(pr_loc,  "profiles","hermeckes_kiesloch_1_20230511_depth.RBR808")
#' pr1 <- read_rbr(pr_name)
#' head(pr1)
#' pr1a <- read_rbr(pr_name,
#'   keep = c("depth","temp", "cond"),
#'   remove_lower=0)
#' head(pr1a)
#' }
#'
#' @export

# read_rbr
# filename <- "hermeckes_kiesloch_1_20230511_depth.RBR808"
# newpath <- "inst/extdata/profiles/RBR"
# filename <- file.path(newpath,filename)

read_rbr <- function(filename, keep = "all", header="auto",
                     TZ="UTC", clean=TRUE, ...) {

  # keep <-   c(
  #     "cond",
  #     "temp",
  #     "press_dbar",
  #     "fluor",
  #     "do_sensor_temp",
  #     "do_umol_l",
  #     "ph",
  #     "turb",
  #     "s_press",
  #     "depth",
  #     "salin",
  #     "soundspeed",
  #     "cond_speci",
  #     "do_sat",
  #     "density"
  #   )

  info <- get_profile_info(filename)

  ext <- info["ext"]

  if(!grepl(pattern = "RBR", x = ext)) {
    warning("File does not have RBRxxx extension, attempting anyway...")
  }
  if(header[1]=="auto") {
    header <- c(
      "date",
      "time",
      "cond",
      "temp",
      "press_dbar",
      "fluor",
      "do_sensor_temp",
      "do_umol_l",
      "ph",
      "turb",
      "s_press",
      "depth",
      "salin",
      "soundspeed",
      "cond_speci",
      "do_sat",
      "density"
    )
  }


  dat <-
    utils::read.table(filename,
               skip = 2,
               header = FALSE ,
               col.names = header)

  dt <- as.POSIXct(paste(dat$date, dat$time),
                   format = "%Y-%m-%d %H:%M:%OS", tz=TZ)
  pr_dt = as.POSIXct(cut(dt[1],"min"),tz=TZ)

  if (keep[1] == "all") {
    outvars <- header[!header %in% c("date", "time")]
  } else {
    outvars <- keep
  }

  if (sum(is.na(match(outvars, header))) > 0) {
    # fill any missing columns with NA
    newcols <- outvars[!outvars %in% header]
    for (j in 1:length(newcols)) {
      dat <- cbind(dat, NA)
    }
    names(dat) <- c(header, newcols)
  }

  dat <- data.frame(
    dt = dt,
    pr_dt=pr_dt,
    sonde = ext,
    location = info["loc"],
    dat[, outvars],
    row.names = NULL
  )

  if(clean) {
    if(sum(names(dat) %in% c("press","depth"))>0) {
      dat <- clean_profile(dat, ...)
      } else {
        stop("Cannot clean the profile without a depth column ('press' or 'depth')\nCheck 'keep'")
      }
  }
  return(dat)
}
